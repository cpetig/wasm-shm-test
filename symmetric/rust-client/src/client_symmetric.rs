// Generated by `wit-bindgen` 0.43.0. DO NOT EDIT!
// Options used:
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod test {
    pub mod shm {
        /// this only works as a host provided interface, it can't be composed,
        /// defining it in this WIT is just because of tool compatibilty
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod exchange {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Address {
                handle: _rt::Resource<Address>,
            }
            impl Address {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: usize) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> usize {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> usize {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Address {
                #[inline]
                unsafe fn drop(_handle: usize) {
                    #[link(wasm_import_module = "test:shm/exchange")]
                    unsafe extern "C" {
                        #[allow(non_snake_case)]
                        #[cfg_attr(
                            target_arch = "wasm32",
                            link_name = "[resource-drop]address"
                        )]
                        fn testX3AshmX2FexchangeX00X5Bresource_dropX5Daddress(
                            _: *mut u8,
                        );
                    }
                    unsafe {
                        testX3AshmX2FexchangeX00X5Bresource_dropX5Daddress(
                            _handle as *mut u8,
                        )
                    };
                }
            }
            pub type Bytes = u32;
            pub struct MemoryArea {
                pub addr: Address,
                pub size: Bytes,
            }
            impl ::core::fmt::Debug for MemoryArea {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("MemoryArea")
                        .field("addr", &self.addr)
                        .field("size", &self.size)
                        .finish()
                }
            }
            wit_bindgen::rt::bitflags::bitflags! {
                #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)] pub
                struct AttachOptions : u8 { #[doc =
                " attach memory in write mode (exclusive operation)"] const WRITE = 1 <<
                0; #[doc =
                " write: the data inside this buffer can be read multiple times without breaking ownership semantics"]
                const SHARED = 1 << 1; }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum Error {
                /// no storage provided for attach
                NoStorage,
                /// non-blocking and no data (read) or no room (write) left
                Busy,
                /// add-storage rejects a too small buffer
                WrongSize,
                /// somehow the host decided that it isn't possible to mmap
                Internal,
            }
            impl Error {
                pub fn name(&self) -> &'static str {
                    match self {
                        Error::NoStorage => "no-storage",
                        Error::Busy => "busy",
                        Error::WrongSize => "wrong-size",
                        Error::Internal => "internal",
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        Error::NoStorage => "no storage provided for attach",
                        Error::Busy => {
                            "non-blocking and no data (read) or no room (write) left"
                        }
                        Error::WrongSize => "add-storage rejects a too small buffer",
                        Error::Internal => {
                            "somehow the host decided that it isn't possible to mmap"
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for Error {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Error")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl ::core::fmt::Display for Error {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{} (error {})", self.name(), * self as i32)
                }
            }
            impl std::error::Error for Error {}
            impl Error {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> Error {
                    if !cfg!(debug_assertions) {
                        return unsafe { ::core::mem::transmute(val) };
                    }
                    match val {
                        0 => Error::NoStorage,
                        1 => Error::Busy,
                        2 => Error::WrongSize,
                        3 => Error::Internal,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Memory {
                handle: _rt::Resource<Memory>,
            }
            impl Memory {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: usize) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> usize {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> usize {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Memory {
                #[inline]
                unsafe fn drop(_handle: usize) {
                    #[link(wasm_import_module = "test:shm/exchange")]
                    unsafe extern "C" {
                        #[allow(non_snake_case)]
                        #[cfg_attr(
                            target_arch = "wasm32",
                            link_name = "[resource-drop]memory"
                        )]
                        fn testX3AshmX2FexchangeX00X5Bresource_dropX5Dmemory(_: *mut u8);
                    }
                    unsafe {
                        testX3AshmX2FexchangeX00X5Bresource_dropX5Dmemory(
                            _handle as *mut u8,
                        )
                    };
                }
            }
            impl Memory {
                #[allow(unused_unsafe, clippy::all)]
                /// construct a memory buffer by size
                #[allow(async_fn_in_trait)]
                pub fn new(size: Bytes) -> Self {
                    unsafe {
                        #[link(name = "symmetric_sharedmem")]
                        #[link(wasm_import_module = "test:shm/exchange")]
                        unsafe extern "C" {
                            #[allow(non_snake_case)]
                            #[cfg_attr(
                                target_arch = "wasm32",
                                link_name = "[constructor]memory"
                            )]
                            fn testX3AshmX2FexchangeX00X5BconstructorX5Dmemory(
                                _: i32,
                            ) -> *mut u8;
                        }
                        let ret = testX3AshmX2FexchangeX00X5BconstructorX5Dmemory(
                            _rt::as_i32(size),
                        );
                        Memory::from_handle(ret as usize)
                    }
                }
            }
            impl Memory {
                #[allow(unused_unsafe, clippy::all)]
                /// only useful for shared buffers
                #[allow(async_fn_in_trait)]
                pub fn clone(&self) -> Memory {
                    unsafe {
                        #[link(name = "symmetric_sharedmem")]
                        #[link(wasm_import_module = "test:shm/exchange")]
                        unsafe extern "C" {
                            #[allow(non_snake_case)]
                            #[cfg_attr(
                                target_arch = "wasm32",
                                link_name = "[method]memory.clone"
                            )]
                            fn testX3AshmX2FexchangeX00X5BmethodX5DmemoryX2Eclone(
                                _: *mut u8,
                            ) -> *mut u8;
                        }
                        let ret = testX3AshmX2FexchangeX00X5BmethodX5DmemoryX2Eclone(
                            (self).handle() as *mut u8,
                        );
                        Memory::from_handle(ret as usize)
                    }
                }
            }
            impl Memory {
                #[allow(unused_unsafe, clippy::all)]
                /// all non-static member functions implicitely borrow a
                /// memory object as the first argument
                /// attach memory buffer into linear memory
                #[allow(async_fn_in_trait)]
                pub fn attach(&self, opt: AttachOptions) -> Result<MemoryArea, Error> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let flags0 = opt;
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[link(name = "symmetric_sharedmem")]
                        #[link(wasm_import_module = "test:shm/exchange")]
                        unsafe extern "C" {
                            #[allow(non_snake_case)]
                            #[cfg_attr(
                                target_arch = "wasm32",
                                link_name = "[method]memory.attach"
                            )]
                            fn testX3AshmX2FexchangeX00X5BmethodX5DmemoryX2Eattach(
                                _: *mut u8,
                                _: i32,
                                _: *mut u8,
                            );
                        }
                        testX3AshmX2FexchangeX00X5BmethodX5DmemoryX2Eattach(
                            (self).handle() as *mut u8,
                            (flags0.bits() >> 0) as i32,
                            ptr1,
                        );
                        let l2 = i32::from(*ptr1.add(0).cast::<u8>());
                        match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr1
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l4 = *ptr1
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>();
                                    MemoryArea {
                                        addr: Address::from_handle(l3 as usize),
                                        size: l4 as u32,
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l5 = i32::from(
                                        *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                    );
                                    Error::_lift(l5 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl Memory {
                #[allow(unused_unsafe, clippy::all)]
                /// detach buffer, consumed bytes have been written/read
                #[allow(async_fn_in_trait)]
                pub fn detach(&self, consumed: Bytes) -> () {
                    unsafe {
                        #[link(name = "symmetric_sharedmem")]
                        #[link(wasm_import_module = "test:shm/exchange")]
                        unsafe extern "C" {
                            #[allow(non_snake_case)]
                            #[cfg_attr(
                                target_arch = "wasm32",
                                link_name = "[method]memory.detach"
                            )]
                            fn testX3AshmX2FexchangeX00X5BmethodX5DmemoryX2Edetach(
                                _: *mut u8,
                                _: i32,
                            );
                        }
                        testX3AshmX2FexchangeX00X5BmethodX5DmemoryX2Edetach(
                            (self).handle() as *mut u8,
                            _rt::as_i32(consumed),
                        );
                    }
                }
            }
            impl Memory {
                #[allow(unused_unsafe, clippy::all)]
                /// pre-allocate position inside linear memory:
                /// get recommended allocation size
                #[allow(async_fn_in_trait)]
                pub fn minimum_size() -> Bytes {
                    unsafe {
                        #[link(name = "symmetric_sharedmem")]
                        #[link(wasm_import_module = "test:shm/exchange")]
                        unsafe extern "C" {
                            #[allow(non_snake_case)]
                            #[cfg_attr(
                                target_arch = "wasm32",
                                link_name = "[static]memory.minimum-size"
                            )]
                            fn testX3AshmX2FexchangeX00X5BstaticX5DmemoryX2Eminimum_size() -> i32;
                        }
                        let ret = testX3AshmX2FexchangeX00X5BstaticX5DmemoryX2Eminimum_size();
                        ret as u32
                    }
                }
            }
            impl Memory {
                #[allow(unused_unsafe, clippy::all)]
                /// pre-allocate position inside linear memory:
                /// get recommended allocation size for a set of buffers
                #[allow(async_fn_in_trait)]
                pub fn optimum_size(count: u32, size: Bytes) -> Bytes {
                    unsafe {
                        #[link(name = "symmetric_sharedmem")]
                        #[link(wasm_import_module = "test:shm/exchange")]
                        unsafe extern "C" {
                            #[allow(non_snake_case)]
                            #[cfg_attr(
                                target_arch = "wasm32",
                                link_name = "[static]memory.optimum-size"
                            )]
                            fn testX3AshmX2FexchangeX00X5BstaticX5DmemoryX2Eoptimum_size(
                                _: i32,
                                _: i32,
                            ) -> i32;
                        }
                        let ret = testX3AshmX2FexchangeX00X5BstaticX5DmemoryX2Eoptimum_size(
                            _rt::as_i32(&count),
                            _rt::as_i32(size),
                        );
                        ret as u32
                    }
                }
            }
            impl Memory {
                #[allow(unused_unsafe, clippy::all)]
                /// buffers need a position in linear memory to attach to,
                /// this function provides a pre-allocated area,
                /// the area should be at least "minimum-size" big
                #[allow(async_fn_in_trait)]
                pub fn add_storage(buffer: MemoryArea) -> Result<(), Error> {
                    unsafe {
                        #[repr(align(1))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2],
                        );
                        let MemoryArea { addr: addr0, size: size0 } = &buffer;
                        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[link(name = "symmetric_sharedmem")]
                        #[link(wasm_import_module = "test:shm/exchange")]
                        unsafe extern "C" {
                            #[allow(non_snake_case)]
                            #[cfg_attr(
                                target_arch = "wasm32",
                                link_name = "[static]memory.add-storage"
                            )]
                            fn testX3AshmX2FexchangeX00X5BstaticX5DmemoryX2Eadd_storage(
                                _: *mut u8,
                                _: i32,
                                _: *mut u8,
                            );
                        }
                        testX3AshmX2FexchangeX00X5BstaticX5DmemoryX2Eadd_storage(
                            (addr0).take_handle() as *mut u8,
                            _rt::as_i32(size0),
                            ptr1,
                        );
                        let l2 = i32::from(*ptr1.add(0).cast::<u8>());
                        match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*ptr1.add(1).cast::<u8>());
                                    Error::_lift(l3 as u8)
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl Memory {
                #[allow(unused_unsafe, clippy::all)]
                /// optional: create a buffer local to this linear memory
                #[allow(async_fn_in_trait)]
                pub fn create_local(buffer: MemoryArea) -> Memory {
                    unsafe {
                        let MemoryArea { addr: addr0, size: size0 } = &buffer;
                        #[link(name = "symmetric_sharedmem")]
                        #[link(wasm_import_module = "test:shm/exchange")]
                        unsafe extern "C" {
                            #[allow(non_snake_case)]
                            #[cfg_attr(
                                target_arch = "wasm32",
                                link_name = "[static]memory.create-local"
                            )]
                            fn testX3AshmX2FexchangeX00X5BstaticX5DmemoryX2Ecreate_local(
                                _: *mut u8,
                                _: i32,
                            ) -> *mut u8;
                        }
                        let ret = testX3AshmX2FexchangeX00X5BstaticX5DmemoryX2Ecreate_local(
                            (addr0).take_handle() as *mut u8,
                            _rt::as_i32(size0),
                        );
                        Memory::from_handle(ret as usize)
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod pub_sub {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Memory = super::super::super::test::shm::exchange::Memory;
            pub type Bytes = super::super::super::test::shm::exchange::Bytes;
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Subscriber {
                handle: _rt::Resource<Subscriber>,
            }
            impl Subscriber {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: usize) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> usize {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> usize {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Subscriber {
                #[inline]
                unsafe fn drop(_handle: usize) {
                    #[link(wasm_import_module = "test:shm/pub-sub")]
                    unsafe extern "C" {
                        #[allow(non_snake_case)]
                        #[cfg_attr(
                            target_arch = "wasm32",
                            link_name = "[resource-drop]subscriber"
                        )]
                        fn testX3AshmX2Fpub_subX00X5Bresource_dropX5Dsubscriber(
                            _: *mut u8,
                        );
                    }
                    unsafe {
                        testX3AshmX2Fpub_subX00X5Bresource_dropX5Dsubscriber(
                            _handle as *mut u8,
                        )
                    };
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Publisher {
                handle: _rt::Resource<Publisher>,
            }
            impl Publisher {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: usize) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> usize {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> usize {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Publisher {
                #[inline]
                unsafe fn drop(_handle: usize) {
                    #[link(wasm_import_module = "test:shm/pub-sub")]
                    unsafe extern "C" {
                        #[allow(non_snake_case)]
                        #[cfg_attr(
                            target_arch = "wasm32",
                            link_name = "[resource-drop]publisher"
                        )]
                        fn testX3AshmX2Fpub_subX00X5Bresource_dropX5Dpublisher(
                            _: *mut u8,
                        );
                    }
                    unsafe {
                        testX3AshmX2Fpub_subX00X5Bresource_dropX5Dpublisher(
                            _handle as *mut u8,
                        )
                    };
                }
            }
            impl Subscriber {
                #[allow(unused_unsafe, clippy::all)]
                /// subscribers receive memory handles
                #[allow(async_fn_in_trait)]
                pub fn get_stream(
                    &self,
                ) -> wit_bindgen::rt::async_support::StreamReader<Memory> {
                    unsafe {
                        #[link(name = "symmetric_sharedmem")]
                        #[link(wasm_import_module = "test:shm/pub-sub")]
                        unsafe extern "C" {
                            #[allow(non_snake_case)]
                            #[cfg_attr(
                                target_arch = "wasm32",
                                link_name = "[method]subscriber.get-stream"
                            )]
                            fn testX3AshmX2Fpub_subX00X5BmethodX5DsubscriberX2Eget_stream(
                                _: *mut u8,
                            ) -> *mut u8;
                        }
                        let ret = testX3AshmX2Fpub_subX00X5BmethodX5DsubscriberX2Eget_stream(
                            (self).handle() as *mut u8,
                        );
                        wit_bindgen::rt::async_support::StreamReader::new(
                            ret,
                            &super::super::super::wit_stream::vtable0::VTABLE,
                        )
                    }
                }
            }
            impl Subscriber {
                #[allow(unused_unsafe, clippy::all)]
                /// clone
                #[allow(async_fn_in_trait)]
                pub fn clone(original: &Subscriber) -> Subscriber {
                    unsafe {
                        #[link(name = "symmetric_sharedmem")]
                        #[link(wasm_import_module = "test:shm/pub-sub")]
                        unsafe extern "C" {
                            #[allow(non_snake_case)]
                            #[cfg_attr(
                                target_arch = "wasm32",
                                link_name = "[static]subscriber.clone"
                            )]
                            fn testX3AshmX2Fpub_subX00X5BstaticX5DsubscriberX2Eclone(
                                _: *mut u8,
                            ) -> *mut u8;
                        }
                        let ret = testX3AshmX2Fpub_subX00X5BstaticX5DsubscriberX2Eclone(
                            (original).handle() as *mut u8,
                        );
                        Subscriber::from_handle(ret as usize)
                    }
                }
            }
            impl Publisher {
                #[allow(unused_unsafe, clippy::all)]
                /// create new data stream
                #[allow(async_fn_in_trait)]
                pub fn new(elements: u32, element_size: Bytes) -> Self {
                    unsafe {
                        #[link(name = "symmetric_sharedmem")]
                        #[link(wasm_import_module = "test:shm/pub-sub")]
                        unsafe extern "C" {
                            #[allow(non_snake_case)]
                            #[cfg_attr(
                                target_arch = "wasm32",
                                link_name = "[constructor]publisher"
                            )]
                            fn testX3AshmX2Fpub_subX00X5BconstructorX5Dpublisher(
                                _: i32,
                                _: i32,
                            ) -> *mut u8;
                        }
                        let ret = testX3AshmX2Fpub_subX00X5BconstructorX5Dpublisher(
                            _rt::as_i32(&elements),
                            _rt::as_i32(element_size),
                        );
                        Publisher::from_handle(ret as usize)
                    }
                }
            }
            impl Publisher {
                #[allow(unused_unsafe, clippy::all)]
                /// clone
                /// clone: static func(original: borrow<publisher>) -> publisher;
                #[allow(async_fn_in_trait)]
                pub fn subscribers(&self) -> Subscriber {
                    unsafe {
                        #[link(name = "symmetric_sharedmem")]
                        #[link(wasm_import_module = "test:shm/pub-sub")]
                        unsafe extern "C" {
                            #[allow(non_snake_case)]
                            #[cfg_attr(
                                target_arch = "wasm32",
                                link_name = "[method]publisher.subscribers"
                            )]
                            fn testX3AshmX2Fpub_subX00X5BmethodX5DpublisherX2Esubscribers(
                                _: *mut u8,
                            ) -> *mut u8;
                        }
                        let ret = testX3AshmX2Fpub_subX00X5BmethodX5DpublisherX2Esubscribers(
                            (self).handle() as *mut u8,
                        );
                        Subscriber::from_handle(ret as usize)
                    }
                }
            }
            impl Publisher {
                #[allow(unused_unsafe, clippy::all)]
                /// returns a memory buffer and number of already initialized bytes
                /// (from last write)
                #[allow(async_fn_in_trait)]
                pub fn allocate(&self) -> (Memory, Bytes) {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[link(name = "symmetric_sharedmem")]
                        #[link(wasm_import_module = "test:shm/pub-sub")]
                        unsafe extern "C" {
                            #[allow(non_snake_case)]
                            #[cfg_attr(
                                target_arch = "wasm32",
                                link_name = "[method]publisher.allocate"
                            )]
                            fn testX3AshmX2Fpub_subX00X5BmethodX5DpublisherX2Eallocate(
                                _: *mut u8,
                                _: *mut u8,
                            );
                        }
                        testX3AshmX2Fpub_subX00X5BmethodX5DpublisherX2Eallocate(
                            (self).handle() as *mut u8,
                            ptr0,
                        );
                        let l1 = *ptr0.add(0).cast::<*mut u8>();
                        let l2 = *ptr0
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<i32>();
                        (
                            super::super::super::test::shm::exchange::Memory::from_handle(
                                l1 as usize,
                            ),
                            l2 as u32,
                        )
                    }
                }
            }
            impl Publisher {
                #[allow(unused_unsafe, clippy::all)]
                /// send data to clients
                #[allow(async_fn_in_trait)]
                pub fn publish(&self, value: Memory) -> () {
                    unsafe {
                        #[link(name = "symmetric_sharedmem")]
                        #[link(wasm_import_module = "test:shm/pub-sub")]
                        unsafe extern "C" {
                            #[allow(non_snake_case)]
                            #[cfg_attr(
                                target_arch = "wasm32",
                                link_name = "[method]publisher.publish"
                            )]
                            fn testX3AshmX2Fpub_subX00X5BmethodX5DpublisherX2Epublish(
                                _: *mut u8,
                                _: *mut u8,
                            );
                        }
                        testX3AshmX2Fpub_subX00X5BmethodX5DpublisherX2Epublish(
                            (self).handle() as *mut u8,
                            (&value).take_handle() as *mut u8,
                        );
                    }
                }
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    use core::fmt;
    use core::marker;
    use core::sync::atomic::{AtomicUsize, Ordering::Relaxed};
    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        handle: AtomicUsize,
        _marker: marker::PhantomData<T>,
    }
    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    #[allow(clippy::missing_safety_doc)]
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: usize);
    }
    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: usize) -> Self {
            debug_assert!(handle != 0 && handle != 0);
            Self {
                handle: AtomicUsize::new(handle),
                _marker: marker::PhantomData,
            }
        }
        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> usize {
            resource.handle.swap(0, Relaxed)
        }
        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> usize {
            resource.handle.load(Relaxed)
        }
    }
    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource").field("handle", &self.handle).finish()
        }
    }
    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    0 => {}
                    other => T::drop(other),
                }
            }
        }
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
}
pub mod wit_stream {
    #![allow(dead_code, unused_variables, clippy::all)]
    pub trait StreamPayload: Unpin + Sized + 'static {
        const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self>;
    }
    #[doc(hidden)]
    #[allow(unused_unsafe)]
    pub mod vtable0 {
        unsafe fn lift(ptr: *mut u8) -> super::super::test::shm::pub_sub::Memory {
            unsafe {
                let l0 = *ptr.add(0).cast::<*mut u8>();
                super::super::test::shm::exchange::Memory::from_handle(l0 as usize)
            }
        }
        unsafe fn lower(value: super::super::test::shm::pub_sub::Memory, ptr: *mut u8) {
            unsafe {
                *ptr.add(0).cast::<*mut u8>() = (value).take_handle() as *mut u8;
            }
        }
        unsafe fn dealloc_lists(ptr: *mut u8) {
            unsafe {}
        }
        pub static VTABLE: wit_bindgen::rt::async_support::StreamVtable<
            super::super::test::shm::pub_sub::Memory,
        > = wit_bindgen::rt::async_support::StreamVtable::<
            super::super::test::shm::pub_sub::Memory,
        > {
            layout: unsafe {
                ::std::alloc::Layout::from_size_align_unchecked(
                    ::core::mem::size_of::<*const u8>(),
                    ::core::mem::size_of::<*const u8>(),
                )
            },
            lift: Some(lift),
            lower: Some(lower),
        };
        impl super::StreamPayload for super::super::test::shm::pub_sub::Memory {
            const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self> = &VTABLE;
        }
    }
    /// Creates a new Component Model `stream` with the specified payload type.
    pub fn new<T: StreamPayload>() -> (
        wit_bindgen::rt::async_support::StreamWriter<T>,
        wit_bindgen::rt::async_support::StreamReader<T>,
    ) {
        wit_bindgen::rt::async_support::stream_new::<T>(T::VTABLE)
    }
}
#[rustfmt::skip]
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.43.0:test:shm:client:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1136] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xf3\x07\x01A\x02\x01\
A\x06\x01B!\x04\0\x07address\x03\x01\x01y\x04\0\x05bytes\x03\0\x01\x01r\x02\x05s\
tart\x02\x03end\x02\x04\0\x12initialized-region\x03\0\x03\x01i\0\x01r\x02\x04add\
r\x05\x04size\x02\x04\0\x0bmemory-area\x03\0\x06\x01n\x02\x05write\x06shared\x04\
\0\x0eattach-options\x03\0\x08\x01m\x04\x0ano-storage\x04busy\x0awrong-size\x08i\
nternal\x04\0\x05error\x03\0\x0a\x04\0\x06memory\x03\x01\x01i\x0c\x01@\x01\x04si\
ze\x02\0\x0d\x04\0\x13[constructor]memory\x01\x0e\x01h\x0c\x01@\x01\x04self\x0f\0\
\x0d\x04\0\x14[method]memory.clone\x01\x10\x01j\x01\x07\x01\x0b\x01@\x02\x04self\
\x0f\x03opt\x09\0\x11\x04\0\x15[method]memory.attach\x01\x12\x01@\x02\x04self\x0f\
\x08consumed\x02\x01\0\x04\0\x15[method]memory.detach\x01\x13\x01@\0\0\x02\x04\0\
\x1b[static]memory.minimum-size\x01\x14\x01@\x02\x05county\x04size\x02\0\x02\x04\
\0\x1b[static]memory.optimum-size\x01\x15\x01j\0\x01\x0b\x01@\x01\x06buffer\x07\0\
\x16\x04\0\x1a[static]memory.add-storage\x01\x17\x01@\x01\x06buffer\x07\0\x0d\x04\
\0\x1b[static]memory.create-local\x01\x18\x03\0\x11test:shm/exchange\x05\0\x02\x03\
\0\0\x06memory\x02\x03\0\0\x05bytes\x01B\x19\x02\x03\x02\x01\x01\x04\0\x06memory\
\x03\0\0\x02\x03\x02\x01\x02\x04\0\x05bytes\x03\0\x02\x04\0\x0asubscriber\x03\x01\
\x04\0\x09publisher\x03\x01\x01h\x04\x01i\x01\x01f\x01\x07\x01@\x01\x04self\x06\0\
\x08\x04\0\x1d[method]subscriber.get-stream\x01\x09\x01i\x04\x01@\x01\x08origina\
l\x06\0\x0a\x04\0\x18[static]subscriber.clone\x01\x0b\x01i\x05\x01@\x02\x08eleme\
ntsy\x0celement-size\x03\0\x0c\x04\0\x16[constructor]publisher\x01\x0d\x01h\x05\x01\
@\x01\x04self\x0e\0\x0a\x04\0\x1d[method]publisher.subscribers\x01\x0f\x01o\x02\x07\
\x03\x01@\x01\x04self\x0e\0\x10\x04\0\x1a[method]publisher.allocate\x01\x11\x01@\
\x02\x04self\x0e\x05value\x07\x01\0\x04\0\x19[method]publisher.publish\x01\x12\x03\
\0\x10test:shm/pub-sub\x05\x03\x04\0\x0ftest:shm/client\x04\0\x0b\x0c\x01\0\x06c\
lient\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.236.\
0\x10wit-bindgen-rust\x060.43.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen::rt::maybe_link_cabi_realloc();
}
