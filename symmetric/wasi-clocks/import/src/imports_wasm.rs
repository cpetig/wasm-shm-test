// Generated by `wit-bindgen` 0.44.0. DO NOT EDIT!
// Options used:
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod wasi {
    pub mod clocks {
        /// This interface common types used throughout wasi:clocks.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            /// A duration of time, in nanoseconds.
            pub type Duration = u64;
        }
        /// WASI Monotonic Clock is a clock API intended to let users measure elapsed
        /// time.
        ///
        /// It is intended to be portable at least between Unix-family platforms and
        /// Windows.
        ///
        /// A monotonic clock is a clock which has an unspecified initial value, and
        /// successive reads of the clock will produce non-decreasing values.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod monotonic_clock {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Duration = super::super::super::wasi::clocks::types::Duration;
            /// An instant in time, in nanoseconds. An instant is relative to an
            /// unspecified initial value, and can only be compared to instances from
            /// the same monotonic-clock.
            pub type Instant = u64;
            #[allow(unused_unsafe, clippy::all)]
            /// Read the current value of the clock.
            ///
            /// The clock is monotonic, therefore calling this function repeatedly will
            /// produce a sequence of non-decreasing values.
            ///
            /// For completeness, this function traps if it's not possible to represent
            /// the value of the clock in an `instant`. Consequently, implementations
            /// should ensure that the starting time is low enough to avoid the
            /// possibility of overflow in practice.
            #[allow(async_fn_in_trait)]
            pub fn now() -> Instant {
                unsafe {
                    #[link(
                        wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[allow(non_snake_case)]
                        #[cfg_attr(target_arch = "wasm32", link_name = "now")]
                        fn wasiX3AclocksX2Fmonotonic_clockX400X2E3X2E0_rc_2025_08_15X00now() -> i64;
                    }
                    let ret = wasiX3AclocksX2Fmonotonic_clockX400X2E3X2E0_rc_2025_08_15X00now();
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Query the resolution of the clock. Returns the duration of time
            /// corresponding to a clock tick.
            #[allow(async_fn_in_trait)]
            pub fn get_resolution() -> Duration {
                unsafe {
                    #[link(
                        wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[allow(non_snake_case)]
                        #[cfg_attr(target_arch = "wasm32", link_name = "get-resolution")]
                        fn wasiX3AclocksX2Fmonotonic_clockX400X2E3X2E0_rc_2025_08_15X00get_resolution() -> i64;
                    }
                    let ret = wasiX3AclocksX2Fmonotonic_clockX400X2E3X2E0_rc_2025_08_15X00get_resolution();
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Wait until the specified instant has occurred.
            #[allow(async_fn_in_trait)]
            pub async fn wait_until(when: Instant) -> () {
                unsafe {
                    use wit_bindgen::rt::async_support::Subtask as _Subtask;
                    struct _MySubtask<'a> {
                        _unused: &'a (),
                    }
                    #[allow(unused_parens)]
                    unsafe impl<'a> _Subtask for _MySubtask<'a> {
                        type Params = (Instant,);
                        type Results = ();
                        type ParamsLower = (i64,);
                        const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                            ::core::alloc::Layout::from_size_align_unchecked(0, 1)
                        };
                        const RESULTS_OFFSET: usize = 0;
                        unsafe fn call_import(
                            _params: Self::ParamsLower,
                            _results: *mut u8,
                        ) -> u32 {
                            #[link(
                                wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2025-08-15"
                            )]
                            unsafe extern "C" {
                                #[allow(non_snake_case)]
                                #[cfg_attr(
                                    target_arch = "wasm32",
                                    link_name = "[async-lower][async]wait-until"
                                )]
                                fn call(_: i64) -> i32;
                            }
                            unsafe { call(_params.0) as u32 }
                        }
                        unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                            unsafe {}
                        }
                        unsafe fn params_dealloc_lists_and_own(
                            _params: Self::ParamsLower,
                        ) {
                            unsafe {}
                        }
                        unsafe fn params_lower(
                            (_lower0,): Self::Params,
                            _ptr: *mut u8,
                        ) -> Self::ParamsLower {
                            unsafe { (_rt::as_i64(_lower0),) }
                        }
                        unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {}
                    }
                    _MySubtask::call((when,)).await
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Wait for the specified duration to elapse.
            #[allow(async_fn_in_trait)]
            pub async fn wait_for(how_long: Duration) -> () {
                unsafe {
                    use wit_bindgen::rt::async_support::Subtask as _Subtask;
                    struct _MySubtask<'a> {
                        _unused: &'a (),
                    }
                    #[allow(unused_parens)]
                    unsafe impl<'a> _Subtask for _MySubtask<'a> {
                        type Params = (Duration,);
                        type Results = ();
                        type ParamsLower = (i64,);
                        const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
                            ::core::alloc::Layout::from_size_align_unchecked(0, 1)
                        };
                        const RESULTS_OFFSET: usize = 0;
                        unsafe fn call_import(
                            _params: Self::ParamsLower,
                            _results: *mut u8,
                        ) -> u32 {
                            #[link(
                                wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2025-08-15"
                            )]
                            unsafe extern "C" {
                                #[allow(non_snake_case)]
                                #[cfg_attr(
                                    target_arch = "wasm32",
                                    link_name = "[async-lower][async]wait-for"
                                )]
                                fn call(_: i64) -> i32;
                            }
                            unsafe { call(_params.0) as u32 }
                        }
                        unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
                            unsafe {}
                        }
                        unsafe fn params_dealloc_lists_and_own(
                            _params: Self::ParamsLower,
                        ) {
                            unsafe {}
                        }
                        unsafe fn params_lower(
                            (_lower0,): Self::Params,
                            _ptr: *mut u8,
                        ) -> Self::ParamsLower {
                            unsafe { (_rt::as_i64(_lower0),) }
                        }
                        unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {}
                    }
                    _MySubtask::call((how_long,)).await
                }
            }
        }
        /// WASI Wall Clock is a clock API intended to let users query the current
        /// time. The name "wall" makes an analogy to a "clock on the wall", which
        /// is not necessarily monotonic as it may be reset.
        ///
        /// It is intended to be portable at least between Unix-family platforms and
        /// Windows.
        ///
        /// A wall clock is a clock which measures the date and time according to
        /// some external reference.
        ///
        /// External references may be reset, so this clock is not necessarily
        /// monotonic, making it unsuitable for measuring elapsed time.
        ///
        /// It is intended for reporting the current date and time for humans.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod wall_clock {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            /// A time and date in seconds plus nanoseconds.
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Datetime {
                pub seconds: u64,
                pub nanoseconds: u32,
            }
            impl ::core::fmt::Debug for Datetime {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Datetime")
                        .field("seconds", &self.seconds)
                        .field("nanoseconds", &self.nanoseconds)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Read the current value of the clock.
            ///
            /// This clock is not monotonic, therefore calling this function repeatedly
            /// will not necessarily produce a sequence of non-decreasing values.
            ///
            /// The returned timestamps represent the number of seconds since
            /// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
            /// also known as [Unix Time].
            ///
            /// The nanoseconds field of the output is always less than 1000000000.
            ///
            /// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
            /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
            #[allow(async_fn_in_trait)]
            pub fn now() -> Datetime {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[link(
                        wasm_import_module = "wasi:clocks/wall-clock@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[allow(non_snake_case)]
                        #[cfg_attr(target_arch = "wasm32", link_name = "now")]
                        fn wasiX3AclocksX2Fwall_clockX400X2E3X2E0_rc_2025_08_15X00now(
                            _: *mut u8,
                        );
                    }
                    wasiX3AclocksX2Fwall_clockX400X2E3X2E0_rc_2025_08_15X00now(ptr0);
                    let l1 = *ptr0.add(0).cast::<i64>();
                    let l2 = *ptr0.add(8).cast::<i32>();
                    let result3 = Datetime {
                        seconds: l1 as u64,
                        nanoseconds: l2 as u32,
                    };
                    result3
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Query the resolution of the clock.
            ///
            /// The nanoseconds field of the output is always less than 1000000000.
            #[allow(async_fn_in_trait)]
            pub fn get_resolution() -> Datetime {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[link(
                        wasm_import_module = "wasi:clocks/wall-clock@0.3.0-rc-2025-08-15"
                    )]
                    unsafe extern "C" {
                        #[allow(non_snake_case)]
                        #[cfg_attr(target_arch = "wasm32", link_name = "get-resolution")]
                        fn wasiX3AclocksX2Fwall_clockX400X2E3X2E0_rc_2025_08_15X00get_resolution(
                            _: *mut u8,
                        );
                    }
                    wasiX3AclocksX2Fwall_clockX400X2E3X2E0_rc_2025_08_15X00get_resolution(
                        ptr0,
                    );
                    let l1 = *ptr0.add(0).cast::<i64>();
                    let l2 = *ptr0.add(8).cast::<i32>();
                    let result3 = Datetime {
                        seconds: l1 as u64,
                        nanoseconds: l2 as u32,
                    };
                    result3
                }
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
}
#[rustfmt::skip]
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.44.0:wasi:clocks@0.3.0-rc-2025-08-15:imports:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 565] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xb7\x03\x01A\x02\x01\
A\x07\x01B\x02\x01w\x04\0\x08duration\x03\0\0\x03\0%wasi:clocks/types@0.3.0-rc-2\
025-08-15\x05\0\x02\x03\0\0\x08duration\x01B\x0c\x02\x03\x02\x01\x01\x04\0\x08du\
ration\x03\0\0\x01w\x04\0\x07instant\x03\0\x02\x01@\0\0\x03\x04\0\x03now\x01\x04\
\x01@\0\0\x01\x04\0\x0eget-resolution\x01\x05\x01@\x01\x04when\x03\x01\0\x04\0\x11\
[async]wait-until\x01\x06\x01@\x01\x08how-long\x01\x01\0\x04\0\x0f[async]wait-fo\
r\x01\x07\x03\0/wasi:clocks/monotonic-clock@0.3.0-rc-2025-08-15\x05\x02\x01B\x05\
\x01r\x02\x07secondsw\x0bnanosecondsy\x04\0\x08datetime\x03\0\0\x01@\0\0\x01\x04\
\0\x03now\x01\x02\x04\0\x0eget-resolution\x01\x02\x03\0*wasi:clocks/wall-clock@0\
.3.0-rc-2025-08-15\x05\x03\x04\0'wasi:clocks/imports@0.3.0-rc-2025-08-15\x04\0\x0b\
\x0d\x01\0\x07imports\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-com\
ponent\x070.238.0\x10wit-bindgen-rust\x060.44.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen::rt::maybe_link_cabi_realloc();
}
